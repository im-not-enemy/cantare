<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Camera Test</title>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.10.6/moment.js"></script>
    <style>
        canvas, video {border: 1px solid gray}
    </style>
</head>
<body>
    <div name="scaner">
        <h1>HTML5カメラ</h1>
        <video id="camera" width="300" height="200"></video>
        <canvas id="picture" width="300" height="200"></canvas>
        <form>
            <button type="button" id="shutter">シャッター</button>
            <button type="button" id="submit">submit</button>
        </form>
    </div>
    <!--
    <div name="upload">
        <div class="upload">
            <form action="http://localhost:3000/scan/upload" method="post" enctype="multipart/form-data">
                <input type="file" name="musicSheetImage" id="file">
                <input type="submit">
            </form>
        </div>
    </div>
    -->
    <div name="trim">
        <button onclick="load_canvas('')">LOAD</button>
        <button onclick="crop_img()">CROP</button><br>
        <input id="scal" type="range" value="" min="10" max="400" oninput="scaling(value)" style="width: 300px;"><br>
        <canvas id="cvs" width="300" height="200"></canvas>
        <canvas id="out" width="100" height="100"></canvas><br>
    </div>
    
    
    <script name="scaner">
        window.onload = () => {
            const video  = document.querySelector("#camera");
            const canvas = document.querySelector("#picture");
            /** カメラ設定 */
            const constraints = {
                audio: false,
                video: {
                    width: 300,
                    height: 200,
                    facingMode: "user"   // フロントカメラを利用する
                    //facingMode: { exact: "environment" }  // リアカメラを利用する場合
                }
            }
            /*カメラを<video>と同期*/
            navigator.mediaDevices.getUserMedia(constraints)
                .then( (stream) => {
                    video.srcObject = stream;
                    video.onloadedmetadata = (e) => {video.play()};
                })
                .catch((err) => {
                    console.log(err.name + ": " + err.message);
                });

            /* シャッターボタン */
            document.querySelector("#shutter").addEventListener("click", () => {
                const ctx = canvas.getContext("2d");
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            });
            /* submit button */
            document.getElementById("submit").onclick = (event) => {
                const canvas = document.getElementById("picture");
                const dataurl = canvas.toDataURL("image/png");
                const binary = atob(dataurl.split(',')[1])
                const buffer = new Uint8Array(binary.length)
                for (let i=0; i<binary.length; i++){
                    buffer[i] = binary.charCodeAt(i)
                }
                const blob = new Blob([buffer.buffer],{type:"image/png"})

                const formdata = new FormData()
                const now = moment().format('YYYYMMDDHHmmss')
                formdata.append('musicSheetImage',blob,`${now}.png`)

                axios.post('http://localhost:3000/scan/upload',formdata,{
                    headers:{'content-type':'multipart/form-data'}
                })
            }
        };
    </script>

    <script name="upload">
        var file = document.getElementById('file');
        var canvas = document.getElementById('picture'); //
        //var canvas = document.getElementById('canvas');
        //var canvasWidth = 400;
        //var canvasHeight = 300;
        var uploadImgSrc;

        // Canvasの準備
        //canvas.width = canvasWidth;
        //canvas.height = canvasHeight;
        var ctx = canvas.getContext('2d');

        function loadLocalImage(e) {
            // ファイル情報を取得
            var fileData = e.target.files[0];

            // 画像ファイル以外は処理を止める
            if(!fileData.type.match('image.*')) {
                alert('画像を選択してください');
                return;
            }

            // FileReaderオブジェクトを使ってファイル読み込み
            var reader = new FileReader();
            // ファイル読み込みに成功したときの処理
            reader.onload = function() {
                // Canvas上に表示する
                uploadImgSrc = reader.result;
                canvasDraw();
            }
            // ファイル読み込みを実行
            reader.readAsDataURL(fileData);
        }

        // ファイルが指定された時にloadLocalImage()を実行
        file.addEventListener('change', loadLocalImage, false);

        // Canvas上に画像を表示する
        function canvasDraw() {
            // canvas内の要素をクリアする
            //ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            //ctx.clearRect(0, 0);//

            // Canvas上に画像を表示
            var img = new Image();
            img.src = uploadImgSrc;
            img.onload = function() {
                //ctx.drawImage(img, 0, 0, canvasWidth, this.height * (canvasWidth / this.width));
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);//
            }
        }
    </script>

    <script name="trim">
        const cvs = document.getElementById( 'cvs' )
        const cw = cvs.width
        const ch = cvs.height
        const out = document.getElementById( 'out' )
        const oh = out.height
        const ow = out.width

        let ix = 0    // 中心座標
        let iy = 0
        let v = 1.0   // 拡大縮小率
        const img  = new Image()
        img.onload = function( _ev ){   // 画像が読み込まれた
            ix = img.width  / 2
            iy = img.height / 2
            let scl = parseInt( cw / img.width * 100 )
            document.getElementById( 'scal' ).value = scl
            scaling( scl )
        }
        function load_canvas( _url ){  // 画像の読み込み
            const canvas = document.getElementById("picture");
            const dataurl = canvas.toDataURL("image/png");
            const binary = atob(dataurl.split(',')[1])
            const buffer = new Uint8Array(binary.length)
            for (let i=0; i<binary.length; i++){
                buffer[i] = binary.charCodeAt(i)
            }
            const blob = new Blob([buffer.buffer],{type:"image/png"})
            img.src = URL.createObjectURL(blob)
        }
        function scaling( _v ) {        // スライダーが変った
            v = parseInt( _v ) * 0.01
            draw_canvas( ix, iy )       // 画像更新
        }

        function draw_canvas( _x, _y ){     // 画像更新
            const ctx = cvs.getContext( '2d' )
            ctx.fillStyle = 'rgb(100, 100, 100)'
            ctx.fillRect( 0, 0, cw, ch )    // 背景を塗る
            ctx.drawImage( img,
                0, 0, img.width, img.height,
                (cw/2)-_x*v, (ch/2)-_y*v, img.width*v, img.height*v,
            )
            ctx.strokeStyle = 'rgba(100, 0, 0, 0.8)'
            ctx.strokeRect( (cw-ow)/2, (ch-oh)/2, ow, oh ) // 赤い枠
        }
        function crop_img(){                // 画像切り取り
            const ctx = out.getContext( '2d' )
            ctx.fillStyle = 'rgb(100, 100, 100)'
            ctx.fillRect( 0, 0, ow, oh )    // 背景を塗る
            ctx.drawImage( img,
                0, 0, img.width, img.height,
                (ow/2)-ix*v, (oh/2)-iy*v, img.width*v, img.height*v,
            )
        }

        let mouse_down = false      // canvas ドラッグ中フラグ
        let sx = 0                  // canvas ドラッグ開始位置
        let sy = 0
        cvs.ontouchstart =
        cvs.onmousedown = function ( _ev ){     // canvas ドラッグ開始位置
            mouse_down = true
            sx = _ev.pageX
            sy = _ev.pageY
            return false // イベントを伝搬しない
        }
        cvs.ontouchend =
        cvs.onmouseout =
        cvs.onmouseup = function ( _ev ){       // canvas ドラッグ終了位置
            if ( mouse_down == false ) return
            mouse_down = false
            draw_canvas( ix += (sx-_ev.pageX)/v, iy += (sy-_ev.pageY)/v )
            return false // イベントを伝搬しない
        }
        cvs.ontouchmove =
        cvs.onmousemove = function ( _ev ){     // canvas ドラッグ中
            if ( mouse_down == false ) return
            draw_canvas( ix + (sx-_ev.pageX)/v, iy + (sy-_ev.pageY)/v )
            return false // イベントを伝搬しない
        }
        cvs.onmousewheel = function ( _ev ){    // canvas ホイールで拡大縮小
            let scl = parseInt( parseInt( document.getElementById( 'scal' ).value ) + _ev.wheelDelta * 0.05 )
            if ( scl < 10  ) scl = 10
            if ( scl > 400 ) scl = 400
            document.getElementById( 'scal' ).value = scl
            scaling( scl )
            return false // イベントを伝搬しない
        }
    </script>
</body>
</html>